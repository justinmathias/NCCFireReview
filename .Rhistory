}
extract(j)
j <- c("5 (78)", "4 (56)")
j
z <- par.extract(j)
z
class(z)
#Parsing out parentheses----
par.extract <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
j <- c("5 (78)", "4 (56)")
j
z <- par.extract(j)
class(z)
z
#Parsing out parentheses----
p.extract <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
#Parsing out parentheses----
extract.prnth <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
j <- c("5 (78)", "4 (56)") #Create data
extract.prnth(j) #Test extraction
libraries(c("tidyverse", "openxlsx", "measurements"))
#First, load all packages
library("easypackages")
libraries(c("tidyverse", "openxlsx", "measurements"))
separate(j)
j <- data.frame(c("5 (78)", "4 (56)")) #Create data
separate(j)
j <- data.frame(Values = c("5 (78)", "4 (56)")) #Create data
j
extract.prnth(j) #Test extraction
extract.prnth(j$Values) #Test extraction
j <- data.frame(Values = #Create data frame
c("5 (78)",
"4 (56)"))
j #View
extract.prnth(j$Values) #Test extraction
j |> separate(Values)
j |> separate(Values, into = c(Values,Error))
j |> separate(Values, into = c("Values","Error"))
j |> separate(Values, into = c("Values","Error"))
j <- data.frame(Value = #Create data frame
c("5 (78)",
"4 (56)"))
j #View
extract.prnth(j$Values) #Test extraction
extract.prnth(j$Value) #Test extraction
j |> separate(Values, into = c("Value","Error"))
j |> separate(Value, into = c("Value","Error"))
y <- j |> separate(Value, into = c("Value","Error"))
y
str(y)
sep.prnth <- function(dat, col) {
sep <- dat |> separate(col, into = c("Value", "Error"))
}
sep.prnth <- function(dat, col, return = "Value") {
sep <- dat |> separate(col, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
j
sep.prnth(j, Value)
sep.prnth(data = j, Value)
sep.prnth(dat = j, Value)
sep.prnth(dat = j, col = Value)
dat <- j
sep <- dat |> separate(col, into = c("Value", "Error"))
sep <- dat |> separate(col, into = c("Value", "Error"))
j
dat <- j
dat |> separate(col, into = c("Value", "Error"))
sep <- dat |> separate(Value, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
sep
j <- data.frame(Value = #Create data frame
c("5 (78)",
"4 (56)"))
j #View
extract.prnth(j$Value) #Test extraction
#Parsing out parentheses----
extract.prnth <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
i <- data.frame(Value = #Create data frame
c("5(78)",
"4(56)"))
j |> separate(Value, into = c("Value","Error"))
i |> separate(Value, into = c("Value","Error"))
#Parsing out parentheses----
extract.prnth <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
sep.prnth <- function(dat, col, return = "Value") {
sep <- dat |> separate({{col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
sep.prnth(dat = j, col = Value)
sep.prnth <- function(dat, col, return = "Value") {
sep <- dat |> separate(col, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
sep.prnth(dat = j, col = Value)
sep.prnth <- function(dat, col, return = "Value") {
sep <- dat |> separate({{col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
sep.prnth(dat = j, col = Value)
sep.prnth <- function(dat, col, return = "Value") {
sep <- dat |> separate({{col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
sep.prnth(dat = j, col = Value)
sep.prnth(dat = j, col = Error)
sep.prnth(dat = j, col = Value)
sep.prnth(dat = j, in_col = Value, return = "Error")
sep.prnth <- function(dat, in_col, return = "Value") {
sep <- dat |> separate({{col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
sep.prnth(dat = j, in_col = Value, return = "Error")
sep.prnth <- function(dat, in_col, return = "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
sep.prnth(dat = j, in_col = Value, return = "Error")
#Parsing out parentheses----
j <- data.frame(Value = #Create data frame
c("5 (78)",
"4 (56)"))
extract.prnth <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
sep.prnth <- function(dat, in_col, return = "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
extract.prnth(j)
extract.prnth(j$Value)
extract.prnth <- function(dat, in_col) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(dat$in_col, gregexpr("\\(.*?\\)", dat$in_col)))
return(as.numeric(extracted))
}
extract.prnth(j, Value)
extract.prnth <- function(dat, in_col) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches({{dat$in_col}}, gregexpr("\\(.*?\\)", {{dat$in_col}})))
return(as.numeric(extracted))
}
sep.prnth <- function(dat, in_col, return = "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else {
return(sep$Error)
}
}
extract.prnth(j, Value)
extract.prnth <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
extract.prnth(x)
extract.prnth(j)
extract.prnth <- function(x) { #Create function to extract vars within parentheses
extracted <- gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", x)))
return(as.numeric(extracted))
}
extract.prnth(j$Value)
sep.prnth <- function(dat, in_col, return = "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} elseif {
sep.prnth <- function(dat, in_col, return = "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else if {
sep.prnth <- function(dat, in_col, return = "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
if (return == "Value") {
return(sep$Value)
} else if (return == "Error"){
return(sep$Error)
} else {
return("Must be Value or Error")
}
}
sep.prnth(j, Value)
sep.prnth(j, Value, return = "Error")
suppre
suppressWarnings()
suppressWarnings(separate())
suppressWarnings(separate)
sep.prnth(j, Value, return = "Error")
sep.prnth <- function(dat, in_col, return = "Value") {
if (return = "Both"){
sep.prnth <- function(dat, in_col, return = "Value") {
if (return = "Both"){
sep.prnth <- function(dat, in_col, return = "Value") {
if (return == "Both"){
dat |> separate({{in_col}}, into = c("Value", "Error"))
} else if (return == "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Value)
} else if (return == "Error") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Error)
} else {
return("Must be Both, Value, or Error")
}
}
sep.prnth(j, in_col = Value)
sep.prnth <- function(dat, in_col, return = "Both") {
if (return == "Both"){
dat |> separate({{in_col}}, into = c("Value", "Error"))
} else if (return == "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Value)
} else if (return == "Error") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Error)
} else {
return("Must be Both, Value, or Error")
}
}
sep.prnth(j, in_col = Value)
sep.prnth(j, in_col = Value, return = "Both")
sep.prnth(j, in_col = Value, return = "Value")
sep.prnth(j, in_col = Value, return = "Error")
sep.prnth(j, in_col = Value, return = "Both") #Test!
#Parsing out parentheses----
sep.prnth <- function(dat, in_col, return = "Both") {
defaultW <- getOption("warn")
options(warn = -1)
if (return == "Both"){
dat |> separate({{in_col}}, into = c("Value", "Error"))
} else if (return == "Value") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Value)
} else if (return == "Error") {
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Error)
} else {
return("Must be Both, Value, or Error")
}
options(warn = defaultW)
}
j <- data.frame(Value = #Create data frame
c("5 (78)",
"4 (56)"))
sep.prnth(j, in_col = Value, return = "Both") #Test!
sep.prnth(j, in_col = Value, return = "Both") #Test!
#Parsing out parentheses----
sep.prnth <- function(dat, in_col, return = "Both") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = defaultW)
dat |> separate({{in_col}}, into = c("Value", "Error"))
} else if (return == "Value") {
defaultW <- getOption("warn")
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Value)
} else if (return == "Error") {
defaultW <- getOption("warn")
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Error)
} else {
return("Must be Both, Value, or Error")
}
}
j <- data.frame(Value = #Create data frame
c("5 (78)",
"4 (56)"))
sep.prnth(j, in_col = Value, return = "Both") #Test!
#Parsing out parentheses----
sep.prnth <- function(dat, in_col, return = "Both") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Value", "Error"))
} else if (return == "Value") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Value)
} else if (return == "Error") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "Error"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$Error <- as.numeric(sep$Error)
return(sep$Error)
} else {
return("Must be Both, Value, or Error")
}
}
j <- data.frame(Value = #Create data frame
c("5 (78)",
"4 (56)"))
sep.prnth(j, in_col = Value, return = "Both") #Test!
sep.prnth(j, in_col = Value, return = "Value") #Test!
sep.prnth(j, in_col = Value, return = "Error") #Test!
#Parsing out parentheses----
sep.prnth <- function(dat, in_col, return = "Both") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Value", "StdErr"))
} else if (return == "Value") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "StdErr"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$StdErr <- as.numeric(sep$StdErr)
return(sep$Value)
} else if (return == "StdErr") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "StdErr"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$StdErr <- as.numeric(sep$StdErr)
return(sep$StdErr)
} else {
return("Must be Both, Value, or StdErr")
}
}
y <- data.frame(Value = #Create test data frame
c("5 ± 78",
"4 ± 56"))
sep.prnth(x, in_col = Value, return = "StdErr") #Test!
##Created on 9/26/2022 by Justin Mathias ##
##This script will serve as a central hub for commonly utilized functions for ##
##the NCC Fire Review.
#First, load all packages
library("easypackages")
libraries(c("tidyverse", "openxlsx", "measurements"))
sep.prnth(x, in_col = Value, return = "StdErr") #Test!
x <- data.frame(Value = #Create test data frame
c("5 (78)",
"4 (56)"))
y <- data.frame(Value = #Create test data frame
c("5 ± 78",
"4 ± 56"))
sep.prnth(x, in_col = Value, return = "StdErr") #Test!
sep.prnth(y, in_col = Value, return = "StdErr") #Test!
sep.prnth(y, in_col = Value, return = "StdErr") #Test!
sep.prnth(c(x,y), in_col = Value, return = "StdErr") #Test!
sep.prnth(x, in_col = Value, return = "StdErr") #Test!
sep.prnth(y, in_col = Value, return = "StdErr") #Test!
##Created on 9/26/2022 by Justin Mathias ##
##This script will serve as a central hub for commonly utilized functions for ##
##the NCC Fire Review.
#First, load all packages
library("easypackages")
libraries(c("tidyverse", "openxlsx", "measurements"))
# Functions added by justin ----------------------------------------------------------
##Working with lat/lon----
#Let's start by creating functions that we will then wrap into a single function
#We will build out complexity later to deal with formatting
dms.to.dd <- function(dms) {
dd <- conv_unit(dms, from = "deg_min_sec", to = "dec_deg")
}
dd.to.dms <- function(dd) {
dms <- conv_unit(dd, from = "dec_deg", to = "deg_min_sec")
}
coord.convert <- function(coord, fn){
fns <- c("dms.to.dd", "dd.to.dms") #First list all possible functions
if(!fn %in% fns){
stop(paste0("Specified function must be one of:"), paste(fns, " ")) #Write error message if fn isn't listed
}
if(fn == "dms.to.dd"){ #Function for dms to dd
dd <- dms.to.dd(coord)
return(round(as.numeric(dd), 6))
} else if (fn == "dd.to.dms") { #Function for dd to dms
dms <- dd.to.dms(coord)
return(dms)
}
}
#Parsing out parentheses----
sep.prnth <- function(dat, in_col, return = "Both") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Value", "StdErr"))
} else if (return == "Value") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "StdErr"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$StdErr <- as.numeric(sep$StdErr)
return(sep$Value)
} else if (return == "StdErr") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "StdErr"))
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
sep$StdErr <- as.numeric(sep$StdErr)
return(sep$StdErr)
} else {
return("Must be Both, Value, or StdErr")
}
}
x <- data.frame(Value = #Create test data frame
c("5 (78)",
"4 (56)"))
y <- data.frame(Value = #Create test data frame
c("5 ± 78",
"4 ± 56"))
sep.prnth(y, in_col = Value, return = "StdErr") #Test! Works on parentheses and plus/minus!
x
y
sep.prnth(x, in_col = Value, return = "StdErr") #Test! Works on parentheses and plus/minus!)
sep.prnth(y, in_col = Value, return = "StdErr") #Test! Works on parentheses and plus/minus!)
#Tests
coord.convert("21 35 45", "dms.to.dd")
x <- data.frame(Value = #Create test data frame
c("5(78)",
"4 (56)"))
sep.prnth(x, in_col = Value, return = "StdErr") #Test! Works on parentheses and plus/minus!
