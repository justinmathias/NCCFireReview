coord.convert("21 35 45", "dms.to.dd") #It works!
#Parsing out data (works for parentheses and plus/minus)----
sep.data <- function(dat, in_col, return = "Both") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = -1)
dat %>% separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
} else if (return == "Value") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
options(warn = defaultW)
return(sep$Value)
} else if (return == "StdErr") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
options(warn = defaultW)
return(sep$StdErr)
} else {
return("Must be Both, Value, or StdErr")
}
}
x <- data.frame(Value = #Create test data frame
c("5(78)",
"4 (56)",
"4 ± 56",
"4±56"))
sep.data(x, in_col = Value) #Test! Works on parentheses and plus/minus!
#Parsing out lat/lon----
sep.coords <- function(dat, in_col, return = "LatLon") {
if (return == "LatLon"){
defaultW <- getOption("warn")
options(warn = -1)
dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE) #Separate can only handle one argument. Use regex to do the job
} else if (return == "Lat") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lat)
} else if (return == "Lon") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lon)
} else {
return("Must be LatLon, Lat, or Lon")
}
}
x <- data.frame("latlon" =
c("43.5/-67.9",
"43.5,-67.9",
"43.5, -67.9",
"43.5 /-67.9"))
sep.coords(x, in_col = "latlon") #It works!
# Dealing with units ------------------------------------------------------
#We will rely on the 'measurements' package to do the heavy lifting
convertSoilC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("molC", from) == TRUE) { #If units are in MOLES convert dimensions
from1 <- stri_replace_all_regex(from, #First remove the C and convert to moles
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
denominator <- sub('.*_per_', '', from) #Snag the denominator for unit conversion
molC <- conv_multiunit(x = val, from = from1, to = paste0("mol / ",denominator)) #Convert given units to molC
gC <- molC*12.01 #Convert moles of carbon to grams of carbon
to1 <- stri_replace_all_regex(to, #Define to units in correct format
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(gC, paste0("g / ",denominator), to1) #Use function from measurements package for conversion
out
} else if (grepl("C", from) == TRUE) { #If the units are already in terms of CARBON, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else  {
val1 <- val #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kg_per_m2", "g / m2")
convertTreeC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("molC", from) == TRUE) { #If units are in MOLES convert dimensions
from1 <- stri_replace_all_regex(from, #First remove the C and convert to moles
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
denominator <- sub('.*_per_', '', from) #Snag the denominator for unit conversion
molC <- conv_multiunit(x = val, from = from1, to = paste0("mol / ",denominator)) #Convert given units to molC
gC <- molC*12.01 #Convert moles of carbon to grams of carbon
to1 <- stri_replace_all_regex(to, #Define to units in correct format
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(gC, paste0("g / ",denominator), to1) #Use function from measurements package for conversion
out
} else if (grepl("C", from) == TRUE) { #If the units are already in terms of CARBON, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else  {
val1 <- val*0.45 #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
# Calculate organic carbon stock in Mg ha-1 from SoilGrids database ------------------
#Uses data returned from fetchSoilGrids using the soilDB package
calc_soilC <- function(bdod, soc, hzdept, hzdepb) {
#bdod: Bulk density of the fine earth fraction in cg/cm^3, need to convert to g/cm^3 first.
#soc: Soil organic content in the fine earth fraction in dg/kg, need to convert to g/g first.
bdod1 <- bdod*0.01 #g soil per cubic cm
soc1 <- soc*0.1/1000 #g C per g soil
ocd <- bdod1*soc1 #organic carbon density, g C per cubic cm
#hzdept is the soil horizon top depth in cm
#hzdepb is the soil horizon bottom depth in cm
#Output organic carbon stocks in MgC per ha for the depth layer provided
out <- ocd*0.000001*(hzdepb-hzdept)*0.00000001 #MgC per ha
out
}
# Scaling soil C depth ------------------------------------------------------
scale.depth <- function(inValue, inDepth_cm, outDepth_cm = 5) { #This function will linearly scale soil C content on an areas basis given depth. Defaults to 0-5cm output
scaledValue <- inValue*(outDepth_cm/inDepth_cm)
scaledValue
}
scale.depth(inValue = 1, inDepth_cm = 10, outDepth_cm = 5)
#Create function to deal with NA values in sum
na.sum <- function(...) {
sum(..., na.rm = TRUE)
}
#Notes from meeting 10/19/22
#soilgrids.org for scale.depth function
#R package: https://rdrr.io/cran/soilDB/man/fetchSoilGrids.html
#GFED assigned locations instead of biomes
#https://lter.github.io/som-website/database.html
#Think about backing out bulk density for the %C soil data
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual column headers are
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
rm(x)
#
# #Wrangle soils data into format appropriate to scale C with depth
# soilsFinal <- soilsData %>% mutate(soilOrgC_MgC_per_ha = calc_soilC(bdodmean, socmean, hzdept, hzdepb), #Calculate C content for each soil layer by area
#                                    soilOrgC_MgC_per_ha_per_cmdepth = soilOrgC_MgC_per_ha/(hzdepb - hzdept)) %>%  #Standardize by depth profile
#   group_by(id) %>% #Group by ID to create sums within groups.
#   mutate(TotalC = sum(soilOrgC_MgC_per_ha), #Get sum of soilOrgC for proportion
#          TotalC_depth = sum(soilOrgC_MgC_per_ha_per_cmdepth)) %>% #Get sum of soilOrgC for proportion
#   ungroup() %>%
#   select(label, id, hzdept, soilOrgC_MgC_per_ha, soilOrgC_MgC_per_ha_per_cmdepth, TotalC, TotalC_depth) %>% #Select only columns of interest
#   mutate(PropC_depth = soilOrgC_MgC_per_ha_per_cmdepth/TotalC_depth) #Calculate proportion of C in each depth layer
soilsFinal <- read.xlsx("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/soilsFinal.xlsx")
View(soilsFinal)
soilsFinal %>%
ggplot(aes(x = hzdept, y = PropC_depth, color = id)) +
geom_point() +
geom_line() +
theme(legend.position = "none") +
coord_flip() +
xlim(c(100,0))
belowground %>% select(UniqueID) %>% mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_"))
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm", "tidyverse", "soilDB", "aqp", "rhdf5"))
theme_set(theme_clean(base_size = 13)) #Set ggplot2 theme
locations <- belowground %>% select(UniqueID) %>% mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_"))
libraries(c("terra", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm", "soilDB", "aqp", "rhdf5", "tidyverse"))
locations <- belowground %>% select(UniqueID) %>% mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_"))
#Nature Climate Change review
#Created by Justin Mathias 9/26/2022
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm", "soilDB", "aqp", "rhdf5", "tidyverse"))
theme_set(theme_clean(base_size = 13)) #Set ggplot2 theme
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual column headers are
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
#
# #Wrangle soils data into format appropriate to scale C with depth
# soilsFinal <- soilsData %>% mutate(soilOrgC_MgC_per_ha = calc_soilC(bdodmean, socmean, hzdept, hzdepb), #Calculate C content for each soil layer by area
#                                    soilOrgC_MgC_per_ha_per_cmdepth = soilOrgC_MgC_per_ha/(hzdepb - hzdept)) %>%  #Standardize by depth profile
#   group_by(id) %>% #Group by ID to create sums within groups.
#   mutate(TotalC = sum(soilOrgC_MgC_per_ha), #Get sum of soilOrgC for proportion
#          TotalC_depth = sum(soilOrgC_MgC_per_ha_per_cmdepth)) %>% #Get sum of soilOrgC for proportion
#   ungroup() %>%
#   select(label, id, hzdept, soilOrgC_MgC_per_ha, soilOrgC_MgC_per_ha_per_cmdepth, TotalC, TotalC_depth) %>% #Select only columns of interest
#   mutate(PropC_depth = soilOrgC_MgC_per_ha_per_cmdepth/TotalC_depth) #Calculate proportion of C in each depth layer
soilsFinal <- read.xlsx("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/soilsFinal.xlsx")
locations <- belowground %>% select(UniqueID) %>% mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_"))
locations <- belowground %>% mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_"))
locations <- belowground %>% mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>% select(UniqueID)
View(locations)
##Created on 9/26/2022 by Justin Mathias ##
##This script will serve as a central hub for commonly utilized functions for ##
##the NCC Fire Review.
#First, load all packages
library("easypackages")
libraries(c("tidyverse", "openxlsx", "measurements", "stringi"))
# Functions added by justin ----------------------------------------------------------
##Working with lat/lon----
#Let's start by creating functions that we will then wrap into a single function
#We will build out complexity later to deal with formatting
dms.to.dd <- function(dms, dms2 = NULL) {
if (is.null(dms2) != TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd2 <- round(as.numeric(conv_unit(dms2, from = "deg_min_sec", to = "dec_deg")), 4)
paste(dd, dd2, sep = ",")
} else if (is.null(dms2) == TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd
}
}
dd.to.dms <- function(dd, dd2) {
dms <- conv_unit(dd, from = "dec_deg", to = "deg_min_sec")
return(dms)
}
coord.convert <- function(coord, fn){
fns <- c("dms.to.dd", "dd.to.dms") #First list all possible functions
if(!fn %in% fns){
stop(paste0("Specified function must be one of:"), paste(fns, " ")) #Write error message if fn isn't listed
}
if(fn == "dms.to.dd"){ #Function for dms to dd
dd <- dms.to.dd(coord)
return(round(as.numeric(dd), 6))
} else if (fn == "dd.to.dms") { #Function for dd to dms
dms <- dd.to.dms(coord)
return(dms)
}
}
#Tests
coord.convert("21 35 45", "dms.to.dd") #It works!
#Parsing out data (works for parentheses and plus/minus)----
sep.data <- function(dat, in_col, return = "Both") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = -1)
dat %>% separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
} else if (return == "Value") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
options(warn = defaultW)
return(sep$Value)
} else if (return == "StdErr") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
options(warn = defaultW)
return(sep$StdErr)
} else {
return("Must be Both, Value, or StdErr")
}
}
x <- data.frame(Value = #Create test data frame
c("5(78)",
"4 (56)",
"4 ± 56",
"4±56"))
sep.data(x, in_col = Value) #Test! Works on parentheses and plus/minus!
#Parsing out lat/lon----
sep.coords <- function(dat, in_col, return = "LatLon") {
if (return == "LatLon"){
defaultW <- getOption("warn")
options(warn = -1)
dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE) #Separate can only handle one argument. Use regex to do the job
} else if (return == "Lat") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lat)
} else if (return == "Lon") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lon)
} else {
return("Must be LatLon, Lat, or Lon")
}
}
x <- data.frame("latlon" =
c("43.5/-67.9",
"43.5,-67.9",
"43.5, -67.9",
"43.5 /-67.9"))
sep.coords(x, in_col = "latlon") #It works!
# Dealing with units ------------------------------------------------------
#We will rely on the 'measurements' package to do the heavy lifting
convertSoilC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("molC", from) == TRUE) { #If units are in MOLES convert dimensions
from1 <- stri_replace_all_regex(from, #First remove the C and convert to moles
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
denominator <- sub('.*_per_', '', from) #Snag the denominator for unit conversion
molC <- conv_multiunit(x = val, from = from1, to = paste0("mol / ",denominator)) #Convert given units to molC
gC <- molC*12.01 #Convert moles of carbon to grams of carbon
to1 <- stri_replace_all_regex(to, #Define to units in correct format
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(gC, paste0("g / ",denominator), to1) #Use function from measurements package for conversion
out
} else if (grepl("C", from) == TRUE) { #If the units are already in terms of CARBON, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else  {
val1 <- val #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kg_per_m2", "g / m2")
convertTreeC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("molC", from) == TRUE) { #If units are in MOLES convert dimensions
from1 <- stri_replace_all_regex(from, #First remove the C and convert to moles
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
denominator <- sub('.*_per_', '', from) #Snag the denominator for unit conversion
molC <- conv_multiunit(x = val, from = from1, to = paste0("mol / ",denominator)) #Convert given units to molC
gC <- molC*12.01 #Convert moles of carbon to grams of carbon
to1 <- stri_replace_all_regex(to, #Define to units in correct format
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(gC, paste0("g / ",denominator), to1) #Use function from measurements package for conversion
out
} else if (grepl("C", from) == TRUE) { #If the units are already in terms of CARBON, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else  {
val1 <- val*0.45 #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
# Calculate organic carbon stock in Mg ha-1 from SoilGrids database ------------------
#Uses data returned from fetchSoilGrids using the soilDB package
calc_soilC <- function(bdod, soc, hzdept, hzdepb) {
#bdod: Bulk density of the fine earth fraction in cg/cm^3, need to convert to g/cm^3 first.
#soc: Soil organic content in the fine earth fraction in dg/kg, need to convert to g/g first.
bdod1 <- bdod*0.01 #g soil per cubic cm
soc1 <- soc*0.1/1000 #g C per g soil
ocd <- bdod1*soc1 #organic carbon density, g C per cubic cm
#hzdept is the soil horizon top depth in cm
#hzdepb is the soil horizon bottom depth in cm
#Output organic carbon stocks in MgC per ha for the depth layer provided
out <- ocd*0.000001*(hzdepb-hzdept)*0.00000001 #MgC per ha
out
}
# Scaling soil C depth ------------------------------------------------------
scale.depth <- function(inValue, inDepth_cm, outDepth_cm = 5) { #This function will linearly scale soil C content on an areas basis given depth. Defaults to 0-5cm output
scaledValue <- inValue*(outDepth_cm/inDepth_cm)
scaledValue
}
scale.depth(inValue = 1, inDepth_cm = 10, outDepth_cm = 5)
#Create function to deal with NA values in sum
na.sum <- function(...) {
sum(..., na.rm = TRUE)
}
#Notes from meeting 10/19/22
#soilgrids.org for scale.depth function
#R package: https://rdrr.io/cran/soilDB/man/fetchSoilGrids.html
#GFED assigned locations instead of biomes
#https://lter.github.io/som-website/database.html
#Think about backing out bulk density for the %C soil data
locations <- belowground %>%
mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>%
sep.coords(LatLon)
locations <- belowground %>%
mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>%
sep.coords(LatLon) %>%
select(UniqueID, Lat, Lon)
View(locations)
locations <- belowground %>%
mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>%
drop_na(LatLon) %>%
sep.coords(LatLon) %>%
select(UniqueID, Lat, Lon)
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual column headers are
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground %>%
drop_na(LatLon) %>% #Remove NA values only for LatLon column
select(LatLon, 12:29) %>%
group_by(LatLon) %>% #Group by unique LatLon and only include one record per site
filter(row_number() == 1) %>%
sep.coords(LatLon)
bmap[] <- sapply(bmap, as.numeric) #Assign all columns as numeric
str(bmap)
##Belowground map of study locations----
# biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual column headers are
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground %>%
drop_na(LatLon) %>% #Remove NA values only for LatLon column
select(LatLon, 12:29) %>%
group_by(LatLon) %>% #Group by unique LatLon and only include one record per site
filter(row_number() == 1) %>%
sep.coords(LatLon)
bmap[] <- sapply(bmap, as.numeric) #Assign all columns as numeric
str(bmap)
##Belowground map of study locations----
biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
bmap <- cbind(bmap, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(bmap)[names(bmap) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
str(bmap)
View(sep.data)
library(raster)
x <- brick("/Users/justinmathias/Downloads/GFED4.1s_2022_beta.hdf5")
x
x@data$basis_regions
x$basis_regions
plot(x$basis_regions)
View(bmap)
