x <- data.frame(Value = #Create test data frame
c("5(78)",
"4 (56)",
"4 ± 56",
"4±56"))
sep.data(x, in_col = Value) #Test! Works on parentheses and plus/minus!
#Parsing out lat/lon----
sep.coords <- function(dat, in_col, return = "LatLon") {
if (return == "LatLon"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE) #Separate can only handle one argument. Use regex to do the job
} else if (return == "Lat") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lat)
} else if (return == "Lon") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lon)
} else {
return("Must be LatLon, Lat, or Lon")
}
}
x <- data.frame("latlon" =
c("43.5/-67.9",
"43.5,-67.9",
"43.5, -67.9",
"43.5 /-67.9"))
dat <- sep.coords(x, in_col = "latlon")
dat #It works!
# Dealing with units ------------------------------------------------------
#We will rely on the 'measurements' package to do the heavy lifting
convertSoilC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("C", from) == TRUE) { #If the units are already in terms of carbon, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else {
val1 <- val #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kgC_per_m2", "g / m2")
#Nature Climate Change review
#Created by Justin Mathias 9/26/2022
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "tidyverse", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly"))
theme_set(theme_clean(base_size = 13)) #Set ggplot2 theme
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual column headers are
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v2.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon, 12:29) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
bmap[] <- sapply(bmap, as.numeric) #Assign all columns as numeric
str(bmap)
##Belowground map of study locations----
biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
bmap <- cbind(bmap, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(bmap)[names(bmap) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
View(bmap)
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v2.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon, 12:29) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
bmap[] <- sapply(bmap, as.numeric) #Assign all columns as numeric
str(bmap)
##Belowground map of study locations----
# biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
bmap <- cbind(bmap, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(bmap)[names(bmap) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
str(bmap)
View(bmap)
####Map of bmap papers----
bmap |>
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(
legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background = element_blank(),
axis.title.x = element_text(
color = "black",
size = 17,
family = "Arial"
),
axis.title.y = element_text(
color = "black",
size = 17,
family = "Arial"
),
axis.text = element_text(
color = "black",
size = 16,
family = "Arial"
),
panel.border = element_rect(
colour = "black",
fill = NA,
size = .9
),
plot.tag = element_text(
family = "Arial",
size = 18,
face = "bold"
)
) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size = 3, alpha = 0.8), ncol = 2))
####Map of bmap papers----
bmap |>
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(
legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background = element_blank(),
axis.title.x = element_text(
color = "black",
size = 17,
family = "Arial"
),
axis.title.y = element_text(
color = "black",
size = 17,
family = "Arial"
),
axis.text = element_text(
color = "black",
size = 16,
family = "Arial"
),
panel.border = element_rect(
colour = "black",
fill = NA,
size = .9
),
plot.tag = element_text(
family = "Arial",
size = 18,
face = "bold"
)
) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size = 3, alpha = 0.8), ncol = 2))
#NCCapp.R: Shiny app for the NCC Review----
ui <- dashboardPage( #Begin UI. Include menu items and set appearance
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325,
sidebarMenu(
menuItem("Map Overview", tabName = "map"),
menuItem("Aboveground", tabName = "above"),
menuItem("Belowground", tabName = "below"),
menuItem("Modeling", tabName = "model"),
menuItem("Emissions", tabName = "emissions"),
menuItem("Total Carbon Dynamics", tabName = "Cdynamics"),
menuItem("Policy Implications", tabName = "policy")
)),
dashboardBody(#Begin dashboard body.
),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
# Summary stats -----------------------------------------------------------
bstats <- belowground |> select(12:29) #Select binary indexed columns for summary stats
bstats[] <- sapply(bstats, as.numeric) #Assign all columns as numeric
str(bstats) #Confirm numeric
#Create quick function to deal with NA values in sum
na.sum <- function(...) {
sum(..., na.rm = TRUE)
}
bstats |> is.na()
View(belowground)
install.packages("wordcloud")
libraries(c("terra", "tidyverse", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud"))
wordcloud(belowground$Study.Type)
install.packages("tm")
libraries(c("terra", "tidyverse", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm"))
libraries(c("terra", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm", "tidyverse"))
wordcloud(belowground$Study.Type)
#Study type wordcloud
wordcloud(words = belowground$Study.Type, min.freq = 1,
max.words=200, random.order=FALSE, rot.per=0.35,
colors=brewer.pal(8, "Dark2"))
#Study type wordcloud
wordcloud(words = belowground$Study.Type, min.freq = 1,
max.words=200, random.order=FALSE,
colors=brewer.pal(8, "Dark2"))
#Study type wordcloud
unique(belowground$Study.Type)
wordcloud(words = belowground$Study.Type, min.freq = 1,
max.words=200, random.order=FALSE,
colors=brewer.pal(8, "Dark2"))
View(belowground)
wordcloud(words = belowground$Region, min.freq = 1,
max.words=200, random.order=FALSE,
colors=brewer.pal(8, "Dark2"))
wordcloud(words = belowground$Region, min.freq = 1,
max.words=200, random.order=FALSE,
colors=brewer.pal(8, "Dark2"))
wordcloud(words = belowground$Severity, min.freq = 1,
max.words=200, random.order=FALSE,
colors=brewer.pal(8, "Dark2"))
belowground %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_density()
colnames(belowground)
belowground %>%
select(TimeSinceFire_years) %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_density()
belowground$TimeSinceFire_years <- as.numeric(belowground$TimeSinceFire_years)
belowground %>%
select(TimeSinceFire_years) %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_density()
belowground %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_density()
belowground %>%
select(TimeSinceFire_years) %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_density(fill = "blue")
belowground %>%
select(TimeSinceFire_years) %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_density(fill = "blue", alpha = 0.5)
belowground %>%
select(TimeSinceFire_years) %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_hist(fill = "blue", alpha = 0.5)
belowground %>%
select(TimeSinceFire_years) %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_histogram(fill = "blue", alpha = 0.5)
belowground %>%
select(TimeSinceFire_years) %>%
ggplot(aes(x = TimeSinceFire_years)) +
geom_density(fill = "blue", alpha = 0.5)
#What units are given?
unique(belowground$SoilC_Units)
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm", "tidyverse"))
theme_set(theme_clean(base_size = 13)) #Set ggplot2 theme
# Carbon density ----------------------------------------------------------
#First, extract data for each biome using Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
biomes <- vect("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/NCCFireReview/Data/Ecoregions2017/Ecoregions2017.shp")
#Nature Climate Change review
#Created by Justin Mathias 9/26/2022
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm", "tidyverse"))
theme_set(theme_clean(base_size = 13)) #Set ggplot2 theme
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual column headers are
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v2.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground %>%
drop_na(LatLon) %>% #Remove NA values only for LatLon column
select(LatLon, 12:29) %>%
group_by(LatLon) %>% #Group by unique LatLon and only include one record per site
filter(row_number() == 1) %>%
sep.coords(LatLon)
bmap[] <- sapply(bmap, as.numeric) #Assign all columns as numeric
str(bmap)
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
bmap <- cbind(bmap, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(bmap)[names(bmap) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
str(bmap)
####Map of bmap papers----
bmap %>%
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(
legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background = element_blank(),
axis.title.x = element_text(
color = "black",
size = 17,
family = "Arial"
),
axis.title.y = element_text(
color = "black",
size = 17,
family = "Arial"
),
axis.text = element_text(
color = "black",
size = 16,
family = "Arial"
),
panel.border = element_rect(
colour = "black",
fill = NA,
size = .9
),
plot.tag = element_text(
family = "Arial",
size = 18,
face = "bold"
)
) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size = 3, alpha = 0.8), ncol = 2))
#What units are given?
unique(belowground$SoilC_Units)
unique(belowground$SoilC1_Depth_cm)
# Scaling soil C depth ------------------------------------------------------
scale.depth <- function(inValue, inDepth_cm, outDepth_cm = 5) {
scaledValue <- inValue*(outDepth_cm/inDepth_cm)
scaledValue
}
scale.depth(inValue = 5, inDepth_cm = 5)
scale.depth(inValue = 5, inDepth_cm = 5, outDepth_cm = 10)
scale.depth(inValue = 5, inDepth_cm = 5, outDepth_cm = 2.5)
scale.depth(inValue = 5, inDepth_cm = 1, outDepth_cm = 5)
scale.depth(inValue = 5, inDepth_cm = 1, outDepth_cm = 5)
scale.depth(inValue = 5, inDepth_cm = 1, outDepth_cm = 5)
#What units are given?
unique(belowground$SoilC_Units)
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual column headers are
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v2.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground %>%
drop_na(LatLon) %>% #Remove NA values only for LatLon column
select(LatLon, 12:29) %>%
group_by(LatLon) %>% #Group by unique LatLon and only include one record per site
filter(row_number() == 1) %>%
sep.coords(LatLon)
bmap[] <- sapply(bmap, as.numeric) #Assign all columns as numeric
str(bmap)
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
bmap <- cbind(bmap, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(bmap)[names(bmap) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
str(bmap)
#What units are given?
unique(belowground$SoilC_Units)
soilcinclude <- c("kgC_per_m2",
"gC_per_m2",
"MgC_per_ha",
"mgC_per_cm2",
"gC_per_cm2",
"kgC_per_ha",
"mgC_per_ha",
"molC_per_m2")
soilCinclude <- c("kgC_per_m2",
"gC_per_m2",
"MgC_per_ha",
"mgC_per_cm2",
"gC_per_cm2",
"kgC_per_ha",
"mgC_per_ha",
"molC_per_m2")
belowground %>%
filter(SoilC_Units %in% soilCinclude)
colnames(belowground)
soilC <- belowground[,1:37]
colnames(soilC)
colnames(soilC)
colnames(soilC) %>%
filter(SoilC_Units %in% soilCinclude)
colnames(soilC) %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
View(soilC)
class(soilC)
str(soilC)
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
soilCinclude <- c("kgC_per_m2", #For now, only include soils on area basis
"gC_per_m2",
"MgC_per_ha",
"mgC_per_cm2",
"gC_per_cm2",
"kgC_per_ha",
"mgC_per_ha",
"molC_per_m2")
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude) %>%
mutate()
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude) %>%
mutate()
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude) %>%
mutate()
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude) %>%
mutate()
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
colnames(belowground)
soilC <- belowground[,c(31,39)]
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
soilC <- belowground[,c(31,40)]
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
soilC <- belowground[,c(31,50)]
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
soilC <- belowground[,c(31:32,50)]
soilC %>%
dplyr::filter(SoilC_Units %in% soilCinclude)
