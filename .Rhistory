SoilC1_Control_StockData = sep.data(., in_col = SoilC1_Control_StockData, return = "Value"), #Use custom function to return numeric values
SoilC1_Burned1_StockData = sep.data(., in_col = SoilC1_Burned1_StockData, return = "Value"), #Use custom function to return numeric values
) %>%
mutate( #Convert soilC stocks to MgC_per_ha
SoilC1_Control_StockData_MgC_ha = unlist(pmap(list(SoilC1_Control_StockData, SoilC_Units_Control_StockData, "Mg / hectare"), convertSoilC)), #Convert to MgC per ha, pmap is the purrr equivalent to mapply in base R
SoilC1_Burned1_StockData_MgC_ha = unlist(pmap(list(SoilC1_Burned1_StockData, SoilC_Units_Control_StockData, "Mg / hectare"), convertSoilC)), #Convert to MgC per ha, pmap is the purrr equivalent to mapply in base R
SoilC1_Control_StockData_MgC_ha_scaled = scale.depth(SoilC1_Control_StockData_MgC_ha, SoilC1_Depth_cm_Control_StockData, outDepth_cm = 10), #Scale based on proportion of C at depth
SoilC1_Burned1_StockData_MgC_ha_scaled = scale.depth(SoilC1_Burned1_StockData_MgC_ha, SoilC1_Depth_cm_Control_StockData, outDepth_cm = 10), #Scale based on proportion of C at depth
SoilC1_Delta_MgC_ha_scaled = (SoilC1_Burned1_StockData_MgC_ha_scaled - SoilC1_Control_StockData_MgC_ha_scaled)
)
###Quick simple stats
soilStat1 <- SoilCarea %>%
dplyr::select(UniqueID,
SoilC1_Control_StockData_MgC_ha_scaled,
SoilC1_Burned1_StockData_MgC_ha_scaled) %>%
pivot_longer(names_to = "Case", values_to = "SoilC_Mg_ha", -UniqueID)
summary(aov(SoilC_Mg_ha ~ Case, data = soilStat1))
###Scale given soil C stocks to 0-5cm depth
SoilCarea <- soilCarea %>% #Work with soil C on area basis
drop_na( #Drop rows where NA exists (i.e. no data) for the following columns
SoilC1_Depth_cm_Control_StockData
) %>%
mutate( #Extract value from all records.
SoilC1_Control_StockData = sep.data(., in_col = SoilC1_Control_StockData, return = "Value"), #Use custom function to return numeric values
SoilC1_Burned1_StockData = sep.data(., in_col = SoilC1_Burned1_StockData, return = "Value"), #Use custom function to return numeric values
) %>%
mutate( #Convert soilC stocks to MgC_per_ha
SoilC1_Control_StockData_MgC_ha = unlist(pmap(list(SoilC1_Control_StockData, SoilC_Units_Control_StockData, "Mg / hectare"), convertSoilC)), #Convert to MgC per ha, pmap is the purrr equivalent to mapply in base R
SoilC1_Burned1_StockData_MgC_ha = unlist(pmap(list(SoilC1_Burned1_StockData, SoilC_Units_Control_StockData, "Mg / hectare"), convertSoilC)), #Convert to MgC per ha, pmap is the purrr equivalent to mapply in base R
SoilC1_Control_StockData_MgC_ha_scaled = scale.depth(SoilC1_Control_StockData_MgC_ha, SoilC1_Depth_cm_Control_StockData), #Scale based on proportion of C at depth
SoilC1_Burned1_StockData_MgC_ha_scaled = scale.depth(SoilC1_Burned1_StockData_MgC_ha, SoilC1_Depth_cm_Control_StockData), #Scale based on proportion of C at depth
SoilC1_Delta_MgC_ha_scaled = (SoilC1_Burned1_StockData_MgC_ha_scaled - SoilC1_Control_StockData_MgC_ha_scaled)
)
###Quick simple stats
soilStat1 <- SoilCarea %>%
dplyr::select(UniqueID,
SoilC1_Control_StockData_MgC_ha_scaled,
SoilC1_Burned1_StockData_MgC_ha_scaled) %>%
pivot_longer(names_to = "Case", values_to = "SoilC_Mg_ha", -UniqueID)
summary(aov(SoilC_Mg_ha ~ Case, data = soilStat1))
###Quick simple stats
#soilStat1 <-
SoilCarea %>%
dplyr::select(UniqueID,
SoilC1_Control_StockData_MgC_ha_scaled,
SoilC1_Burned1_StockData_MgC_ha_scaled) %>%
pivot_longer(names_to = "Case", values_to = "SoilC_Mg_ha", -UniqueID) %>%
ggplot(aes(x = Case, y = SoilC_Mg_ha)) +
geom_jitter() +
geom_boxplot(alpha = 0)
###Quick simple stats
#soilStat1 <-
SoilCarea %>%
dplyr::select(UniqueID, Biome,
SoilC1_Control_StockData_MgC_ha_scaled,
SoilC1_Burned1_StockData_MgC_ha_scaled) %>%
pivot_longer(names_to = "Case", values_to = "SoilC_Mg_ha", -UniqueID) %>%
ggplot(aes(x = Case, y = SoilC_Mg_ha)) +
geom_jitter() +
geom_boxplot(alpha = 0)
colnames(soilCarea)
View(belowground)
View(belowground)
##Append biome to each observation given lat/lon
belowground %>%
sep.coords(LatLon)
##Append biome to each observation given lat/lon
belowground <- belowground %>% sep.coords(LatLon) #First separate Latitude and Longitude
#Create a new dataframe, coords, so we can extract data from belowground
coords <- data.frame(belowground$Lon, belowground$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
##Append biome to each observation given lat/lon
belowground <- belowground %>% drop_na(LatLon) %>% sep.coords(LatLon) #First separate Latitude and Longitude
#Read files, starting with row three on belowground sheet, where actual column headers are ------------------------------------------------------
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
##Append biome to each observation given lat/lon
belowground <- belowground %>% drop_na(LatLon) %>% sep.coords(LatLon) #First separate Latitude and Longitude
#Create a new dataframe, coords, so we can extract data from belowground
coords <- data.frame(belowground$Lon, belowground$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
##Append biome to each observation given lat/lon
Belowground <- belowground %>%
mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>% #First create UniqueID to join later
drop_na(LatLon) %>% sep.coords(LatLon) #First separate Latitude and Longitude
#Read files, starting with row three on belowground sheet, where actual column headers are ------------------------------------------------------
belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
##Append biome to each observation given lat/lon
Belowground <- belowground %>%
mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>% #First create UniqueID to join later
drop_na(LatLon) %>% sep.coords(LatLon) #First separate Latitude and Longitude
View(Belowground)
#Create a new dataframe, coords, so we can extract data from belowground
coords <- data.frame(Belowground$Lon, Belowground$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
Belowground <- cbind(Belowground, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(Belowground)[names(Belowground) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
Belowground
tst <- left_join(belowground, Belowground)
belowground <- left_join(belowground, Belowground)
belowground$Biome
#Read files, starting with row three on belowground sheet, where actual column headers are ------------------------------------------------------
{belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
##Read in biomes shapefile----
biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
##Append biome to each observation given lat/lon
Belowground <- belowground %>%
mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>% #First create UniqueID to join later
drop_na(LatLon) %>% sep.coords(LatLon) #First separate Latitude and Longitude
#Create a new dataframe, coords, so we can extract data from belowground
coords <- data.frame(Belowground$Lon, Belowground$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
Belowground <- cbind(Belowground, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(Belowground)[names(Belowground) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
belowground <- left_join(belowground, Belowground)
}
View(soilsCarbon)
##Create dataframe containing UniqueIDs and Lat/Lon to retrieve biome information----
soilsLocations <- belowground %>%
# mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>%
# drop_na(LatLon) %>%
# group_by(UniqueID) %>% #Group by UniqueID to remove duplicate rows
# filter(row_number() == 1) %>%  #Remove duplicate ID rows
# ungroup() %>%
# sep.coords(LatLon) %>%
dplyr::select(UniqueID, Lat, Lon)
View(soilsLocations)
#Join dataframes to get locations for soilC
soilsCarbon2 <- left_join(soilsFinal, soilsLocations)
all.equal(soilsCarbon, soilsCarbon2)
View(soilsCarbon)
View(soilsCarbon2)
##Create dataframe containing UniqueIDs and Lat/Lon to retrieve biome information----
soilsLocations <- belowground %>%
# mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>%
# drop_na(LatLon) %>%
# group_by(UniqueID) %>% #Group by UniqueID to remove duplicate rows
# filter(row_number() == 1) %>%  #Remove duplicate ID rows
# ungroup() %>%
# sep.coords(LatLon) %>%
dplyr::select(UniqueID, Lat, Lon, Biome)
#Join dataframes to get locations for soilC
soilsCarbon2 <- left_join(soilsFinal, soilsLocations)
all.equal(soilsCarbon, soilsCarbon2)
##Create dataframe containing UniqueIDs and Lat/Lon to retrieve biome information----
soilsLocations <- belowground %>%
# mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>%
# drop_na(LatLon) %>%
# group_by(UniqueID) %>% #Group by UniqueID to remove duplicate rows
# filter(row_number() == 1) %>%  #Remove duplicate ID rows
# ungroup() %>%
# sep.coords(LatLon) %>%
dplyr::select(UniqueID, Lat, Lon, Biome)
#Join dataframes to get locations for soilC
soilsCarbon <- left_join(soilsFinal, soilsLocations)
##Fit three parameter asymptotic regression model to soilC data----
#Create a lookup table to replace depth labels with values
depth.lookup <- c("0-5" = 2.5,
"5-15" = 10,
"15-30" = 22.5,
"30-60" = 45,
"60-100" = 80,
"100-200" = 150)
soilsCarbon$LabelDepth <- depth.lookup[soilsCarbon$label]
soilDat <- soilsCarbon %>% group_by(LabelDepth) %>%
summarise(PropC_depth = mean(PropC_depth, na.rm = T)) %>%
mutate(PropC_depth_cumu = cumsum(PropC_depth))
soilCmod <- drm(PropC_depth_cumu ~ LabelDepth, data = soilDat, fct = AR.3())
summary(soilCmod)
inset <- soilsCarbon %>%
ggplot(aes(x = LabelDepth, y = PropC_depth)) +
geom_point(alpha = 0.05) +
stat_smooth(method = "gam", formula = y ~ s(x, k = 6), size = 0.7) +
coord_flip() +
xlim(c(150,0)) +
theme(legend.position = "none",
axis.text = element_text(color = "black", size = 8),
axis.title = element_text(size = 9)) +
xlab("Soil Depth (cm)") +
ylab("Non-Cumulative")
#Create new data for smoother line
main <- soilDat %>% #Rename figure later
ggplot(aes(x = LabelDepth, y = PropC_depth_cumu)) +
geom_point(size = 2) +
geom_line(aes(y = predict(soilCmod)), color = "forestgreen", size = 0.8) +
theme(legend.position = "none",
axis.text = element_text(color = "black")) +
xlab("Soil Depth (cm)") +
ylab("Cumulative Proportion \n of Soil Carbon") +
coord_flip() +
xlim(c(150,0))
main + inset_element(inset, 0.025, 0.025, 0.6, 0.65)
ggsave("SoilPlot2.tiff", units = c("in"), width = 3.9, height = 3.25, dpi = 300)
ggsave("SoilPlot.tiff", units = c("in"), width = 3.9, height = 3.25, dpi = 300)
main + inset_element(inset, 0.025, 0.025, 0.625, 0.675)
ggsave("SoilPlot.tiff", units = c("in"), width = 3.9, height = 3.25, dpi = 300)
##Created on 9/26/2022 by Justin Mathias ##
##This script will serve as a central hub for commonly utilized functions for ##
##the NCC Fire Review.
#First, load all packages
library("easypackages")
libraries(c("openxlsx", "measurements", "stringi", "tidyverse"))
# Functions added by justin ----------------------------------------------------------
##Working with lat/lon----
#Let's start by creating functions that we will then wrap into a single function
#We will build out complexity later to deal with formatting
dms.to.dd <- function(dms, dms2 = NULL) {
if (is.null(dms2) != TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd2 <- round(as.numeric(conv_unit(dms2, from = "deg_min_sec", to = "dec_deg")), 4)
paste(dd, dd2, sep = ",")
} else if (is.null(dms2) == TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd
}
}
dd.to.dms <- function(dd, dd2) {
dms <- conv_unit(dd, from = "dec_deg", to = "deg_min_sec")
return(dms)
}
coord.convert <- function(coord, fn){
fns <- c("dms.to.dd", "dd.to.dms") #First list all possible functions
if(!fn %in% fns){
stop(paste0("Specified function must be one of:"), paste(fns, " ")) #Write error message if fn isn't listed
}
if(fn == "dms.to.dd"){ #Function for dms to dd
dd <- dms.to.dd(coord)
return(round(as.numeric(dd), 6))
} else if (fn == "dd.to.dms") { #Function for dd to dms
dms <- dd.to.dms(coord)
return(dms)
}
}
#Tests
coord.convert("21 35 45", "dms.to.dd") #It works!
#Parsing out data (works for parentheses and plus/minus)----
sep.data <- function(dat, in_col, return = "Value") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Value", "StdErr"), sep = "\\(|\\±|\\)", convert = TRUE)
sep$Value <- as.numeric(sep$Value)
sep$StdErr <- as.numeric(sep$StdErr)
return(sep)
} else if (return == "Value") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Value", "StdErr"), sep = "\\(|\\±|\\)", convert = TRUE)
options(warn = defaultW)
sep$Value <- as.numeric(sep$Value)
return(sep$Value)
} else if (return == "StdErr") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Value", "StdErr"), sep = "\\(|\\±|\\)", convert = TRUE)
options(warn = defaultW)
sep$StdErr <- as.numeric(sep$StdErr)
return(sep$StdErr)
} else {
return("Must be Both, Value, or StdErr")
}
}
x <- data.frame(Value = #Create test data frame
c("5(78)",
"4 (56)",
"4 ± 56",
"4±56"))
sep.data(x, in_col = Value) #Test! Works on parentheses and plus/minus!
#Parsing out lat/lon----
sep.coords <- function(dat, in_col, return = "LatLon") {
if (return == "LatLon"){
defaultW <- getOption("warn")
options(warn = -1)
dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE) #Separate can only handle one argument. Use regex to do the job
} else if (return == "Lat") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lat)
} else if (return == "Lon") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat %>% separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lon)
} else {
return("Must be LatLon, Lat, or Lon")
}
}
x <- data.frame("latlon" =
c("43.5/-67.9",
"43.5,-67.9",
"43.5, -67.9",
"43.5 /-67.9"))
sep.coords(x, in_col = "latlon") #It works!
# Dealing with units ------------------------------------------------------
#We will rely on the 'measurements' package to do the heavy lifting
convertSoilC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("molC", from) == TRUE) { #If units are in MOLES convert dimensions
from1 <- stri_replace_all_regex(from, #First remove the C and convert to moles
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
denominator <- sub('.*_per_', '', from) #Snag the denominator for unit conversion
molC <- conv_multiunit(x = val, from = from1, to = paste0("mol / ",denominator)) #Convert given units to molC
gC <- molC*12.01 #Convert moles of carbon to grams of carbon
to1 <- stri_replace_all_regex(to, #Define to units in correct format
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(gC, paste0("g / ",denominator), to1) #Use function from measurements package for conversion
out
} else if (grepl("C", from) == TRUE) { #If the units are already in terms of CARBON, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else  {
val1 <- val #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kg_per_m2", "g / m2")
convertTreeC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("molC", from) == TRUE) { #If units are in MOLES convert dimensions
from1 <- stri_replace_all_regex(from, #First remove the C and convert to moles
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
denominator <- sub('.*_per_', '', from) #Snag the denominator for unit conversion
molC <- conv_multiunit(x = val, from = from1, to = paste0("mol / ",denominator)) #Convert given units to molC
gC <- molC*12.01 #Convert moles of carbon to grams of carbon
to1 <- stri_replace_all_regex(to, #Define to units in correct format
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(gC, paste0("g / ",denominator), to1) #Use function from measurements package for conversion
out
} else if (grepl("C", from) == TRUE) { #If the units are already in terms of CARBON, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else  {
val1 <- val*0.45 #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
# Calculate organic carbon stock in Mg ha-1 from SoilGrids database ------------------
#Uses data returned from fetchSoilGrids using the soilDB package
calc_soilC <- function(bdod, soc, hzdept, hzdepb) {
#bdod: Bulk density of the fine earth fraction in cg/cm^3, need to convert to g/cm^3 first.
#soc: Soil organic content in the fine earth fraction in dg/kg, need to convert to g/g first.
bdod1 <- bdod*0.01 #g soil per cubic cm
soc1 <- soc*0.1/1000 #g C per g soil
ocd <- bdod1*soc1 #organic carbon density, g C per cubic cm
#hzdept is the soil horizon top depth in cm
#hzdepb is the soil horizon bottom depth in cm
#Output organic carbon stocks in MgC per ha for the depth layer provided
out <- ocd*0.000001*(hzdepb-hzdept)*0.00000001 #MgC per ha
out
}
# Scaling soil C depth ------------------------------------------------------
scale.depth <- function(inValue, inDepth_cm, outDepth_cm = 5) { #This function will linearly scale soil C content on an areas basis given depth. Defaults to 0-5cm output
c <- 0.275595 #Fit via a three parameter asymptotic regression model "AR.3()" using drc R package
d <- 0.966278
e <- 29.836626
y1 <- c + (d-c)*(1-exp(-inDepth_cm/e))
y2 <- c + (d-c)*(1-exp(-outDepth_cm/e))
scaledValue <- inValue*(y2/y1)
scaledValue
}
# Create function to deal with NA values in sum ------------------------------------------------------
na.sum <- function(...) {
sum(..., na.rm = TRUE)
}
# Percent change ------------------------------------------------------
percentchange<-function(FinalValue,InitialValue){
(FinalValue-InitialValue)/InitialValue*100
}
#NCC_Mathias_Belowground
#Created by justin mathias 11/28/22
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly", "wordcloud", "tm", "soilDB", "aqp", "rhdf5", "drc", "tidyverse", "patchwork"))
theme_set(theme_article(base_size = 13)) #Set ggplot2 theme
#Read files, starting with row three on belowground sheet, where actual column headers are ------------------------------------------------------
#Run this chunk of code to get biomes. We need to do it this way because we don't have a lat/lon for every case
{belowground <- read.xlsx("/Users/justinmathias/Downloads/Literature_Data_extraction_NCC_v3.xlsx",
sheet = "Belowground",
startRow = 3)
##Read in biomes shapefile----
biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
##Append biome to each observation given lat/lon
Belowground <- belowground %>%
mutate(UniqueID = paste(RecordID, RecordSubID, sep = "_")) %>% #First create UniqueID to join later
drop_na(LatLon) %>% sep.coords(LatLon) #First separate Latitude and Longitude
#Create a new dataframe, coords, so we can extract data from belowground
coords <- data.frame(Belowground$Lon, Belowground$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
Belowground <- cbind(Belowground, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(Belowground)[names(Belowground) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
belowground <- left_join(belowground, Belowground)
}
#Import soil C data retrieved from soilgrids.org
soilsFinal <- read.xlsx("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/soilsFinal.xlsx")
##Create dataframe containing UniqueIDs and Lat/Lon to retrieve biome information----
soilsLocations <- belowground %>%
dplyr::select(UniqueID, Lat, Lon, Biome)
#Join dataframes to get locations for soilC
soilsCarbon <- left_join(soilsFinal, soilsLocations)
##Fit three parameter asymptotic regression model to soilC data----
#Create a lookup table to replace depth labels with values
depth.lookup <- c("0-5" = 2.5,
"5-15" = 10,
"15-30" = 22.5,
"30-60" = 45,
"60-100" = 80,
"100-200" = 150)
soilsCarbon$LabelDepth <- depth.lookup[soilsCarbon$label]
soilDat <- soilsCarbon %>% group_by(LabelDepth) %>%
summarise(PropC_depth = mean(PropC_depth, na.rm = T)) %>%
mutate(PropC_depth_cumu = cumsum(PropC_depth))
soilCmod <- drm(PropC_depth_cumu ~ LabelDepth, data = soilDat, fct = AR.3())
summary(soilCmod)
##Figure for soilC by depth----
inset <- soilsCarbon %>%
ggplot(aes(x = LabelDepth, y = PropC_depth)) +
geom_point(alpha = 0.05) +
stat_smooth(method = "gam", formula = y ~ s(x, k = 6), size = 0.7) +
coord_flip() +
xlim(c(150,0)) +
theme(legend.position = "none",
axis.text = element_text(color = "black", size = 8),
axis.title = element_text(size = 9)) +
xlab("Soil Depth (cm)") +
ylab("Non-Cumulative")
##Figure for soilC by depth----
inset <- soilsCarbon %>%
ggplot(aes(x = LabelDepth, y = PropC_depth)) +
geom_point(alpha = 0.05) +
stat_smooth(method = "gam", formula = y ~ s(x, k = 6), linewidth = 0.7) +
coord_flip() +
xlim(c(150,0)) +
theme(legend.position = "none",
axis.text = element_text(color = "black", size = 8),
axis.title = element_text(size = 9)) +
xlab("Soil Depth (cm)") +
ylab("Non-Cumulative")
#Create new data for smoother line
main <- soilDat %>% #Rename figure later
ggplot(aes(x = LabelDepth, y = PropC_depth_cumu)) +
geom_point(size = 2) +
geom_line(aes(y = predict(soilCmod)), color = "forestgreen", size = 0.8) +
theme(legend.position = "none",
axis.text = element_text(color = "black")) +
xlab("Soil Depth (cm)") +
ylab("Cumulative Proportion \n of Soil Carbon") +
coord_flip() +
xlim(c(150,0))
main + inset_element(inset, 0.025, 0.025, 0.625, 0.675)
ggsave("SoilPlot.tiff", units = c("in"), width = 3.9, height = 3.25, dpi = 300)
ggsave("SoilPlot.jpg", units = c("in"), width = 3.9, height = 3.25, dpi = 300)
