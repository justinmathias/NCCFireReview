server <- function(input, output) { }
shinyApp(ui, server)
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 300),#Width in pixels
dashboardSidebar(),
dashboardBody()
)
server <- function(input, output) { }
shinyApp(ui, server)
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(),
dashboardBody()
)
server <- function(input, output) { }
shinyApp(ui, server)
## app.R ##
library(shinydashboard)
ui <- dashboardPage(
dashboardHeader(title = "Basic dashboard"),
dashboardSidebar(),
dashboardBody(
# Boxes need to be put in a row (or column)
fluidRow(
box(plotOutput("plot1", height = 250)),
box(
title = "Controls",
sliderInput("slider", "Number of observations:", 1, 100, 50)
)
)
)
)
server <- function(input, output) {
set.seed(122)
histdata <- rnorm(500)
output$plot1 <- renderPlot({
data <- histdata[seq_len(input$slider)]
hist(data)
})
}
shinyApp(ui, server)
ui <- dashboardPage(
dashboardHeader(title = "Basic dashboard"),
## Sidebar content
dashboardSidebar(
sidebarMenu(
menuItem("Dashboard", tabName = "dashboard", icon = icon("dashboard")),
menuItem("Widgets", tabName = "widgets", icon = icon("th"))
)
),
dashboardBody(
# Boxes need to be put in a row (or column)
fluidRow(
box(plotOutput("plot1", height = 250)),
box(
title = "Controls",
sliderInput("slider", "Number of observations:", 1, 100, 50)
)
)
)
)
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody()
)
server <- function(input, output) { }
shinyApp(ui, server)
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody()
skin = "purlpe"
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody()
skin = "purple"
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody()
skin = "purple"
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody(),
skin = "purple"
)
server <- function(input, output) { }
shinyApp(ui, server)
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody(),
skin = "#0f90b0"
)
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody(),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
checkboxInput("somevalue", "Some value", FALSE),
verbatimTextOutput("value")
)
server <- function(input, output) {
output$value <- renderText({ input$somevalue })
}
shinyApp(ui, server)
}
# Create ui
ui <- fluidPage(
numericInput('bzc','bzc',value=2),
numericInput('bzm','bzm',value=2),
checkboxInput('change_sign','Change sign'),
textOutput('text')
)
server <- function(input, output) {
output$text <- renderText({
bzc = ifelse(input$change_sign,-1,1) * input$bzc
bzm = input$bzm
paste0('bzc: ', bzc, ', bzm: ', bzm)
})
}
shinyApp(ui = ui, server = server)
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
checkboxGroupInput("variable", "Variables to show:",
c("Cylinders" = "cyl",
"Transmission" = "am",
"Gears" = "gear")),
tableOutput("data")
)
server <- function(input, output, session) {
output$data <- renderTable({
mtcars[, c("mpg", input$variable), drop = FALSE]
}, rownames = TRUE)
}
shinyApp(ui, server)
ui <- fluidPage(
checkboxGroupInput("icons", "Choose icons:",
choiceNames =
list(icon("calendar"), icon("bed"),
icon("cog"), icon("bug")),
choiceValues =
list("calendar", "bed", "cog", "bug")
),
textOutput("txt")
)
server <- function(input, output, session) {
output$txt <- renderText({
icons <- paste(input$icons, collapse = ", ")
paste("You chose", icons)
})
}
shinyApp(ui, server)
}
server <- function(input, output, session) {
output$data <- renderTable({
mtcars[, c("mpg", input$variable), drop = FALSE]
}, rownames = TRUE)
}
shinyApp(ui, server)
ui <- fluidPage(
checkboxGroupInput("icons", "Choose icons:",
choiceNames =
list(icon("calendar"), icon("bed"),
icon("cog"), icon("bug")),
choiceValues =
list("calendar", "bed", "cog", "bug")
),
textOutput("txt")
)
server <- function(input, output, session) {
output$txt <- renderText({
icons <- paste(input$icons, collapse = ", ")
paste("You chose", icons)
})
}
shinyApp(ui, server)
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody(),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
## NCCapp.R ##
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody(),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
##Created on 9/26/2022 by Justin Mathias ##
##This script will serve as a central hub for commonly utilized functions for ##
##the NCC Fire Review.
#First, load all packages
library("easypackages")
libraries(c("tidyverse", "openxlsx", "measurements"))
# Functions added by justin ----------------------------------------------------------
##Working with lat/lon----
#Let's start by creating functions that we will then wrap into a single function
#We will build out complexity later to deal with formatting
dms.to.dd <- function(dms, dms2 = NULL) {
if (is.null(dms2) != TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd2 <- round(as.numeric(conv_unit(dms2, from = "deg_min_sec", to = "dec_deg")), 4)
paste(dd, dd2, sep = ",")
} else if (is.null(dms2) == TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd
}
}
dd.to.dms <- function(dd, dd2) {
dms <- conv_unit(dd, from = "dec_deg", to = "deg_min_sec")
return(dms)
}
coord.convert <- function(coord, fn){
fns <- c("dms.to.dd", "dd.to.dms") #First list all possible functions
if(!fn %in% fns){
stop(paste0("Specified function must be one of:"), paste(fns, " ")) #Write error message if fn isn't listed
}
if(fn == "dms.to.dd"){ #Function for dms to dd
dd <- dms.to.dd(coord)
return(round(as.numeric(dd), 6))
} else if (fn == "dd.to.dms") { #Function for dd to dms
dms <- dd.to.dms(coord)
return(dms)
}
}
#Tests
coord.convert("21 35 45", "dms.to.dd")
coord.convert("21 35 45", "dm.to.dd") #Should throw an error
dms.to.dd("4 28 40", "114 18 19")
dms.to.dd("52 19 5", "20 51 19")
dms.to.dd("67 46 0 ", "29 35 0")
dms.to.dd(51 27 28", "126 16 24)
dms.to.dd(51 27 28", "126 16 24"")
dms.to.dd("51 27 28", "126 16 24"")
dms.to.dd("51 27 28", "126 16 24)
dms.to.dd("51 27 28", "126 16 24")
dms.to.dd("66 22 0", "-136 43 0")
dms.to.dd("50 49 0", "121 30 0")
#Nature Climate Change review
#Created by Justin Mathias 9/26/2022
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "tidyverse", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard"))
theme_set(theme_clean(base_size = 13)) #Set ggplot2 theme
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual
belowground <- read.xlsx("/Users/justinmathias/Downloads/LitSearch_Revised_Final_DataExtration_V1.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
belowground <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
##Created on 9/26/2022 by Justin Mathias ##
##This script will serve as a central hub for commonly utilized functions for ##
##the NCC Fire Review.
#First, load all packages
library("easypackages")
libraries(c("tidyverse", "openxlsx", "measurements"))
# Functions added by justin ----------------------------------------------------------
##Working with lat/lon----
#Let's start by creating functions that we will then wrap into a single function
#We will build out complexity later to deal with formatting
dms.to.dd <- function(dms, dms2 = NULL) {
if (is.null(dms2) != TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd2 <- round(as.numeric(conv_unit(dms2, from = "deg_min_sec", to = "dec_deg")), 4)
paste(dd, dd2, sep = ",")
} else if (is.null(dms2) == TRUE) {
dd <- round(as.numeric(conv_unit(dms, from = "deg_min_sec", to = "dec_deg")), 4)
dd
}
}
dd.to.dms <- function(dd, dd2) {
dms <- conv_unit(dd, from = "dec_deg", to = "deg_min_sec")
return(dms)
}
coord.convert <- function(coord, fn){
fns <- c("dms.to.dd", "dd.to.dms") #First list all possible functions
if(!fn %in% fns){
stop(paste0("Specified function must be one of:"), paste(fns, " ")) #Write error message if fn isn't listed
}
if(fn == "dms.to.dd"){ #Function for dms to dd
dd <- dms.to.dd(coord)
return(round(as.numeric(dd), 6))
} else if (fn == "dd.to.dms") { #Function for dd to dms
dms <- dd.to.dms(coord)
return(dms)
}
}
#Tests
coord.convert("21 35 45", "dms.to.dd")
coord.convert("21 35 45", "dm.to.dd") #Should throw an error
#Create unique columns for Latitude and Longitude
belowground <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
#Parsing out lat/lon----
sep.coords <- function(dat, in_col, return = "LatLon") {
if (return == "LatLon"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE) #Separate can only handle one argument. Use regex to do the job
} else if (return == "Lat") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
sep$Lat <- as.numeric(sep$Lat)
sep$Lon <- as.numeric(sep$Lon)
return(sep$Lat)
} else if (return == "Lon") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lon)
} else {
return("Must be LatLon, Lat, or Lon")
}
}
#Create unique columns for Latitude and Longitude
belowground <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
##Belowground map of study locations----
biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
View(belowground)
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(belowground$Lon, belowground$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
belowground <- cbind(belowground, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(belowground)[names(belowground) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
View(belowground)
####Map of belowground papers----
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
data = belowground,
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background=element_blank(),
axis.title.x = element_text(color = "black", size = 17, family = "Arial"),
axis.title.y = element_text(color = "black", size = 17, family = "Arial"),
axis.text = element_text(color = "black", size = 16, family = "Arial"),
panel.border = element_rect(colour = "black", fill=NA, size=.9),
plot.tag = element_text(family = "Arial", size = 18, face = "bold")) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size=3, alpha = 0.8), ncol = 2))
colnames(belowground)
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual
belowground <- read.xlsx("/Users/justinmathias/Downloads/LitSearch_Revised_Final_DataExtration_V1.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
bmap <- cbind(bmap, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(bmap)[names(bmap) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
####Map of bmap papers----
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
data = bmap,
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background=element_blank(),
axis.title.x = element_text(color = "black", size = 17, family = "Arial"),
axis.title.y = element_text(color = "black", size = 17, family = "Arial"),
axis.text = element_text(color = "black", size = 16, family = "Arial"),
panel.border = element_rect(colour = "black", fill=NA, size=.9),
plot.tag = element_text(family = "Arial", size = 18, face = "bold")) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size=3, alpha = 0.8), ncol = 2))
#General overview of belowground article contents----
belowground
colnames(belowground)
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual
belowground <- read.xlsx("/Users/justinmathias/Downloads/LitSearch_Revised_Final_DataExtration_V1.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
colnames(belowground)
colnames(belowground)
#General overview of belowground article contents----
belowground |> select(1:29)
#General overview of belowground article contents----
belowground |> select(1:30)
#General overview of belowground article contents----
belowground |> select(1:29)
#Count of records
belowground |> select(Severity)
#Count of records
belowground |> select(Severity) |> drop_na()
#Count of records
belowground |> select(Severity) |> drop_na() |> hist()
#Count of records
belowground |> select(Severity) |> drop_na() |> summary()
#Count of records
belowground |> select(Severity) |> drop_na() |> barplot(prop.table(table(Severity)))
#Count of records
belowground |> select(Severity) |> drop_na() |> barplot(prop.table(table()))
belowground |> select(Severity) |> drop_na()
#Count of records
Sev <- belowground |> select(Severity) |> drop_na() #|> barplot(prop.table(table()))
barplot(prop.table(table(Severity)))
barplot(prop.table(table(Sev)))
#Count of records
Sev <- belowground |> select(Severity) |> drop_na() |> barplot(prop.table(table(.)))
#Count of records
belowground |> select(Severity) |> drop_na() |> group_by(Severity) |> n()
belowground |> select(Severity) |> drop_na()
#Count of records
belowground |> select(Severity) |> drop_na() |>  n()
#Count of records
belowground |> select(Severity) |> drop_na() |>  n(Severity)
#Count of records
belowground |> drop_na(Severity) |>
ggplot(aes(x = Severity, y = count)) +
geom_col(aes(x = Severity, fill = factor(Severity)))
#Count of records
belowground |> drop_na(Severity) |> group_by(Severity) |> summarise(sum)
#Count of records
belowground |> select(Severity) |> drop_na(Severity) |> group_by(Severity) |> summarise(sum)
#General overview of belowground article contents----
belowground |> select(1:29)
colnames(belowground)
#General overview of belowground article contents----
belowground |> select(12:29)
#General overview of belowground article contents----
belowground |> select(12:29) |> summarise(sum)
#General overview of belowground article contents----
belowground |> select(12:29) |> summarise_all(sum)
str(belowground)
#General overview of belowground article contents----
belowground |> select(20:29) |> summarise_all(sum)
