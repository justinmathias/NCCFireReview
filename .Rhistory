replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else {
val1 <- val #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kgC_per_m2", "g_per_m2")
convertSoilC(1, "kgC_per_m2", "g / m2")
convertSoilC(1, "kgC_per_m2", "g_per_m2")
####Map of bmap papers----
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
data = bmap,
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background=element_blank(),
axis.title.x = element_text(color = "black", size = 17, family = "Arial"),
axis.title.y = element_text(color = "black", size = 17, family = "Arial"),
axis.text = element_text(color = "black", size = 16, family = "Arial"),
panel.border = element_rect(colour = "black", fill=NA, size=.9),
plot.tag = element_text(family = "Arial", size = 18, face = "bold")) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size=3, alpha = 0.8), ncol = 2))
####Map of bmap papers----
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
data = bmap,
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background=element_blank(),
axis.title.x = element_text(color = "black", size = 17, family = "Arial"),
axis.title.y = element_text(color = "black", size = 17, family = "Arial"),
axis.text = element_text(color = "black", size = 16, family = "Arial"),
panel.border = element_rect(colour = "black", fill=NA, size=.9),
plot.tag = element_text(family = "Arial", size = 18, face = "bold")) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size=3, alpha = 0.8), ncol = 2))
# Summary stats -----------------------------------------------------------
sums <- belowground |> select(12:29)
# Summary stats -----------------------------------------------------------
bstats <- belowground |> select(12:29)
colnames(bstats)
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual
belowground <- read.xlsx("/Users/justinmathias/Downloads/LitSearch_Revised_Final_DataExtration_V1.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
View(bmap)
str(bmap)
#Parsing out lat/lon----
sep.coords <- function(dat, in_col, return = "LatLon") {
if (return == "LatLon"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE) #Separate can only handle one argument. Use regex to do the job
} else if (return == "Lat") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
sep$Lat <- as.numeric(sep$Lat)
sep$Lon <- as.numeric(sep$Lon)
return(sep$Lat)
} else if (return == "Lon") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
return(sep$Lon)
} else {
return("Must be LatLon, Lat, or Lon")
}
}
x <- data.frame("latlon" =
c("43.5/-67.9",
"43.5,-67.9",
"43.5, -67.9",
"43.5 /-67.9"))
dat <- sep.coords(x, in_col = "latlon")
dat #It works!
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
str(bmap)
#Parsing out lat/lon----
sep.coords <- function(dat, in_col, return = "LatLon") {
if (return == "LatLon"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE) #Separate can only handle one argument. Use regex to do the job
} else if (return == "Lat") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
sep$Lat <- as.numeric(sep$Lat)
sep$Lon <- as.numeric(sep$Lon)
return(sep$Lat)
} else if (return == "Lon") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Lat", "Lon"), sep = "\\/|\\,", convert = TRUE)
options(warn = defaultW)
sep$Lat <- as.numeric(sep$Lat)
sep$Lon <- as.numeric(sep$Lon)
return(sep$Lon)
} else {
return("Must be LatLon, Lat, or Lon")
}
}
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
str(bmap)
dms.to.dd("58 39 44.55", "39 17 48.95")
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual
belowground <- read.xlsx("/Users/justinmathias/Downloads/LitSearch_Revised_Final_DataExtration_V1.xlsx",
sheet = "Belowground",
startRow = 3)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
str(bmap)
colnames(belowground)
#Create unique columns for Latitude and Longitude
bmap <- belowground |>
drop_na(LatLon) |> #Remove NA values only for LatLon column
select(LatLon) |>
group_by(LatLon) |> #Group by unique LatLon and only include one record per site
filter(row_number() == 1) |>
sep.coords(LatLon)
str(bmap)
##Belowground map of study locations----
biomes <- readOGR("/Users/justinmathias/Dropbox/Research/UIdaho Postdoc/Nature Climate Change review/Ecoregions2017/Ecoregions2017.shp") #World biomes from: Dinerstein et al., 2017, An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm
#Create a new dataframe, coords, so we can extract data from the CRU dataset for each year
coords <- data.frame(bmap$Lon, bmap$Lat)
coords.sp <- SpatialPoints(coords) #Coords need to be LongLat
proj4string(coords.sp) = proj4string(biomes) #Need to make sure coordinates match.
#Extract biome information.
bmap <- cbind(bmap, over(coords.sp, biomes)$BIOME_NAME)
#Rename biome column
names(bmap)[names(bmap) == "over(coords.sp, biomes)$BIOME_NAME"] <- "Biome"
####Map of bmap papers----
ggplot() + #Plot
borders("world", colour = "gray40", fill = "gray99") +
theme_article() +
coord_fixed(1.2) +
geom_point(aes(x = Lon, y = Lat, color = Biome),
data = bmap,
alpha = 0.65,
size = 2) +
scale_size_continuous(range = c(1, 8),
breaks = c(5, 10, 15)) +
theme(legend.position = "bottom",
legend.title = element_text(size = 11, family = "Arial"),
legend.text = element_text(size = 11, family = "Arial"),
legend.background=element_blank(),
axis.title.x = element_text(color = "black", size = 17, family = "Arial"),
axis.title.y = element_text(color = "black", size = 17, family = "Arial"),
axis.text = element_text(color = "black", size = 16, family = "Arial"),
panel.border = element_rect(colour = "black", fill=NA, size=.9),
plot.tag = element_text(family = "Arial", size = 18, face = "bold")) +
xlab("Longitude") +
ylab("Latitude") +
guides(color = guide_legend(override.aes = list(size=3, alpha = 0.8), ncol = 2))
#NCCapp.R: Shiny app for the NCC Review----
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325),
dashboardBody(),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
# Summary stats -----------------------------------------------------------
bstats <- belowground |> select(12:29)
colnames(bstats)
# Literature review datasheet metadata extraction -------------------------
#Read files, starting with row three, where actual
belowground <- read.xlsx("/Users/justinmathias/Downloads/LitSearch_Revised_Final_DataExtration_V1.xlsx",
sheet = "Belowground",
startRow = 3)
# Summary stats -----------------------------------------------------------
bstats <- belowground |> select(12:29)
View(bstats)
bstats
str(bstats)
#NCCapp.R: Shiny app for the NCC Review----
ui <- dashboardPage(
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325,
sidebarMenu(
menuItem("Map Overview", tabName = "map"),
menuItem("Aboveground", tabName = "above"),
menuItem("Belowground", tabName = "below"),
menuItem("Modeling", tabName = "model"),
menuItem("Emissions", tabName = "emissions"),
menuItem("Total Carbon Dynamics", tabName = "Cdynamics"),
menuItem("Policy Implications", tabName = "policy")
)),
dashboardBody(),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
install.packages("plotly")
library(plotly)
shinyApp(ui, server)
#NCCapp.R: Shiny app for the NCC Review----
ui <- dashboardPage( #Begin UI. Include menu items and set appearance
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325,
sidebarMenu(
menuItem("Map Overview", tabName = "map"),
menuItem("Aboveground", tabName = "above"),
menuItem("Belowground", tabName = "below"),
menuItem("Modeling", tabName = "model"),
menuItem("Emissions", tabName = "emissions"),
menuItem("Total Carbon Dynamics", tabName = "Cdynamics"),
menuItem("Policy Implications", tabName = "policy")
)),
dashboardBody(#Begin dashboard body.
),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
ui <- dashboardPage( #Begin UI. Include menu items and set appearance
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325,
sidebarMenu(
menuItem("Map Overview", tabName = "map"),
menuItem("Aboveground", tabName = "above"),
menuItem("Belowground", tabName = "below"),
menuItem("Modeling", tabName = "model"),
menuItem("Emissions", tabName = "emissions"),
menuItem("Total Carbon Dynamics", tabName = "Cdynamics"),
menuItem("Policy Implications", tabName = "policy")
)),
dashboardBody(#Begin dashboard body.
tabItem( # Begin 'Map Overview' page
tabName = "map",
h1('Map Overview'),
# Select inputs for plot
fluidRow( column(4, selectInput('xcol_all', 'X-axis variable', xvars)),
column(4, selectInput('ycol_all', 'Y-axis variable', yvars)),
column(4, selectInput('groups_all', 'Group by', all_groups))),
br(),
# Output plot
shinycssloaders::withSpinner(plotlyOutput('all_plots',
width = '100%',  height = '100%'),
type = getOption("spinner.type", default = 5)),
inline = TRUE,
h5(em('Data are a random 2% sample from each site to reduce plotting times.'), align = 'center'),
br()
) # End 'All Sites' page
),
skin = "green"
)
ui <- dashboardPage( #Begin UI. Include menu items and set appearance
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325,
sidebarMenu(
menuItem("Map Overview", tabName = "map"),
menuItem("Aboveground", tabName = "above"),
menuItem("Belowground", tabName = "below"),
menuItem("Modeling", tabName = "model"),
menuItem("Emissions", tabName = "emissions"),
menuItem("Total Carbon Dynamics", tabName = "Cdynamics"),
menuItem("Policy Implications", tabName = "policy")
)),
dashboardBody(#Begin dashboard body.
),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
convertSoilC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("C", from) == TRUE) { #If the units are already in terms of carbon, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else {
val1 <- val #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kgC_per_m2", "g_per_m2")
##Created on 9/26/2022 by Justin Mathias ##
##This script will serve as a central hub for commonly utilized functions for ##
##the NCC Fire Review.
#First, load all packages
library("easypackages")
libraries(c("tidyverse", "openxlsx", "measurements", "stringi"))
convertSoilC(1, "kgC_per_m2", "g_per_m2")
convertSoilC(1, "kgC_per_m2", "g / m2")
convertSoilC(1, "kg_per_m2", "g / m2")
convertSoilC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("C", from) == TRUE) { #If the units are already in terms of carbon, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else {
val1 <- val*0.45 #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kgC_per_m2", "g / m2")
convertSoilC(1, "kg_per_m2", "g / m2")
convertSoilC(1, "kgC_per_m2", "g / m2")
convertSoilC <- function(val, from, to) {
#We want all units to be in terms of carbon
if (grepl("C", from) == TRUE) { #If the units are already in terms of carbon, then do simple conversion
from1 <- stri_replace_all_regex(from,
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val, from1, to1) #Use function from measurements package for conversion
out
} else {
val1 <- val #NEED TO PUT MODIFIER HERE
from1 <- stri_replace_all_regex(from, #Otherwise
pattern=c('C', '_per_'), #Values to remove
replacement=c('', ' / '), #Values to replace with
vectorize=FALSE)
to1 <- stri_replace_all_regex(to,
pattern=c('_per_'), #Values to remove
replacement=c(' / '), #Values to replace with
vectorize=FALSE)
out <- conv_multiunit(val1, from1, to1) #Use function from measurements package for conversion
out
}
}
convertSoilC(1, "kg_per_m2", "g / m2")
convertSoilC(1, "kgC_per_m2", "g / m2")
#Parsing out data (works for parentheses and plus/minus)----
sep.data <- function(dat, in_col, return = "Both") {
if (return == "Both"){
defaultW <- getOption("warn")
options(warn = -1)
dat |> separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
} else if (return == "Value") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
options(warn = defaultW)
return(sep$Value)
} else if (return == "StdErr") {
defaultW <- getOption("warn")
options(warn = -1)
sep <- dat |> separate({{in_col}}, into = c("Value", "StdErr"), convert = TRUE)
options(warn = defaultW)
return(sep$StdErr)
} else {
return("Must be Both, Value, or StdErr")
}
}
x <- data.frame(Value = #Create test data frame
c("5(78)",
"4 (56)",
"4 ± 56",
"4±56"))
sep.data(x, in_col = Value) #Test! Works on parentheses and plus/minus!
ui <- dashboardPage( #Begin UI. Include menu items and set appearance
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325,
sidebarMenu(
menuItem("Map Overview", tabName = "map"),
menuItem("Aboveground", tabName = "above"),
menuItem("Belowground", tabName = "below"),
menuItem("Modeling", tabName = "model"),
menuItem("Emissions", tabName = "emissions"),
menuItem("Total Carbon Dynamics", tabName = "Cdynamics"),
menuItem("Policy Implications", tabName = "policy")
)),
dashboardBody(#Begin dashboard body.
),
skin = "green"
)
server <- function(input, output) { }
#Housekeeping: load packages, set themes, etc.
library("easypackages")
libraries(c("terra", "tidyverse", "ggsci", "ggthemes", "RColorBrewer", "measurements", "stringr", "rayshader", "egg", "rgdal", "openxlsx", "shiny", "shinydashboard",
"plotly"))
theme_set(theme_clean(base_size = 13)) #Set ggplot2 theme
ui <- dashboardPage( #Begin UI. Include menu items and set appearance
dashboardHeader(title = "Nature Climate Change Review",
titleWidth = 325),#Width in pixels
dashboardSidebar(width = 325,
sidebarMenu(
menuItem("Map Overview", tabName = "map"),
menuItem("Aboveground", tabName = "above"),
menuItem("Belowground", tabName = "below"),
menuItem("Modeling", tabName = "model"),
menuItem("Emissions", tabName = "emissions"),
menuItem("Total Carbon Dynamics", tabName = "Cdynamics"),
menuItem("Policy Implications", tabName = "policy")
)),
dashboardBody(#Begin dashboard body.
),
skin = "green"
)
server <- function(input, output) { }
shinyApp(ui, server)
library(ncdf4)
iso <- nc_open("/Users/justinmathias/Downloads/nudged.isogsm_atm.h0.exp1.1982.nc")
iso
library(measurements)
conv_unit(1, "mol", "g")
